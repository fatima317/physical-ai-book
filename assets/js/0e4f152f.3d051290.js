"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[9150],{7981:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"weekly-breakdown/week4/index","title":"Week 4 - Navigation and Path Planning","description":"Learning Objectives","source":"@site/docs/weekly-breakdown/week4/index.mdx","sourceDirName":"weekly-breakdown/week4","slug":"/weekly-breakdown/week4/","permalink":"/physical-ai-book/docs/weekly-breakdown/week4/","draft":false,"unlisted":false,"editUrl":"https://github.com/fatima317/physical-ai-book/tree/main/docs/weekly-breakdown/week4/index.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Week 4 - Navigation and Path Planning"},"sidebar":"tutorialSidebar","previous":{"title":"Week 3 - ROS 2 Advanced Topics","permalink":"/physical-ai-book/docs/weekly-breakdown/week3/"},"next":{"title":"Week 5 - Computer Vision for Robotics","permalink":"/physical-ai-book/docs/weekly-breakdown/week5/"}}');var t=a(4848),o=a(8453);const r={sidebar_position:4,title:"Week 4 - Navigation and Path Planning"},l="Week 4 - Navigation and Path Planning",s={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Navigation Stack Overview",id:"navigation-stack-overview",level:2},{value:"Code Snippets",id:"code-snippets",level:2},{value:"Navigation Node Example",id:"navigation-node-example",level:3},{value:"Costmap Configuration",id:"costmap-configuration",level:3},{value:"Path Planning Algorithm Example",id:"path-planning-algorithm-example",level:3},{value:"URDF Examples",id:"urdf-examples",level:2},{value:"Robot with Navigation Sensors",id:"robot-with-navigation-sensors",level:3},{value:"Kinematics Diagrams",id:"kinematics-diagrams",level:2},{value:"Navigation Hardware Configuration",id:"navigation-hardware-configuration",level:2},{value:"Key Terms",id:"key-terms",level:2},{value:"Learning Checkpoints",id:"learning-checkpoints",level:2},{value:"Quiz Questions",id:"quiz-questions",level:3},{value:"Practical Exercise",id:"practical-exercise",level:3},{value:"Hands-On Exercise",id:"hands-on-exercise",level:2},{value:"Personalization",id:"personalization",level:2},{value:"Translation",id:"translation",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"week-4---navigation-and-path-planning",children:"Week 4 - Navigation and Path Planning"})}),"\n",(0,t.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(e.p,{children:"By the end of this week, you will be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Implement navigation stack components in ROS 2"}),"\n",(0,t.jsx)(e.li,{children:"Create and manage costmaps for obstacle avoidance"}),"\n",(0,t.jsx)(e.li,{children:"Plan paths using various algorithms (Dijkstra, A*, RRT)"}),"\n",(0,t.jsx)(e.li,{children:"Execute navigation goals with obstacle avoidance"}),"\n",(0,t.jsx)(e.li,{children:"Integrate localization and mapping with navigation"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"navigation-stack-overview",children:"Navigation Stack Overview"}),"\n",(0,t.jsx)(e.p,{children:"The ROS 2 Navigation stack consists of several key components that work together to enable autonomous navigation:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"AMCL (Adaptive Monte Carlo Localization)"}),": Localizes the robot in a known map"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Costmap 2D"}),": Maintains obstacle information for planning and control"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Global Planner"}),": Computes optimal path from start to goal"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Local Planner"}),": Executes path following with obstacle avoidance"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Controller"}),": Sends velocity commands to robot hardware"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"code-snippets",children:"Code Snippets"}),"\n",(0,t.jsx)(e.h3,{id:"navigation-node-example",children:"Navigation Node Example"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom nav2_msgs.action import NavigateToPose\nfrom geometry_msgs.msg import PoseStamped\nfrom action_msgs.msg import GoalStatus\nimport tf_transformations\n\nclass NavigationNode(Node):\n\n    def __init__(self):\n        super().__init__('navigation_node')\n\n        # Create action client for navigation\n        self.nav_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')\n\n    def navigate_to_pose(self, x, y, theta):\n        \"\"\"Send navigation goal to the robot\"\"\"\n        # Wait for action server\n        self.nav_client.wait_for_server()\n\n        # Create goal message\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose.header.frame_id = 'map'\n        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()\n\n        # Set position\n        goal_msg.pose.pose.position.x = x\n        goal_msg.pose.pose.position.y = y\n        goal_msg.pose.pose.position.z = 0.0\n\n        # Set orientation (convert theta to quaternion)\n        quat = tf_transformations.quaternion_from_euler(0, 0, theta)\n        goal_msg.pose.pose.orientation.x = quat[0]\n        goal_msg.pose.pose.orientation.y = quat[1]\n        goal_msg.pose.pose.orientation.z = quat[2]\n        goal_msg.pose.pose.orientation.w = quat[3]\n\n        # Send goal\n        self.get_logger().info(f'Sending navigation goal to ({x}, {y})')\n        send_goal_future = self.nav_client.send_goal_async(goal_msg)\n        send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        \"\"\"Handle goal response\"\"\"\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info('Goal rejected')\n            return\n\n        self.get_logger().info('Goal accepted')\n        get_result_future = goal_handle.get_result_async()\n        get_result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        \"\"\"Handle result callback\"\"\"\n        status = future.result().status\n        result = future.result().result\n\n        if status == GoalStatus.STATUS_SUCCEEDED:\n            self.get_logger().info('Navigation succeeded')\n        else:\n            self.get_logger().info(f'Navigation failed with status: {status}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    nav_node = NavigationNode()\n\n    # Example: Navigate to position (2.0, 1.0) facing 90 degrees\n    nav_node.navigate_to_pose(2.0, 1.0, 1.57)\n\n    rclpy.spin(nav_node)\n    nav_node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(e.h3,{id:"costmap-configuration",children:"Costmap Configuration"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'# costmap_common_params.yaml\nglobal_costmap:\n  global_frame: map\n  robot_base_frame: base_link\n  update_frequency: 10.0\n  publish_frequency: 10.0\n  width: 20\n  height: 20\n  resolution: 0.05\n  origin_x: -10.0\n  origin_y: -10.0\n  plugins:\n    - {name: static_layer, type: "nav2_costmap_2d::StaticLayer"}\n    - {name: inflation_layer, type: "nav2_costmap_2d::InflationLayer"}\n\nlocal_costmap:\n  global_frame: odom\n  robot_base_frame: base_link\n  update_frequency: 10.0\n  publish_frequency: 10.0\n  width: 5\n  height: 5\n  resolution: 0.05\n  origin_x: -2.5\n  origin_y: -2.5\n  plugins:\n    - {name: obstacle_layer, type: "nav2_costmap_2d::ObstacleLayer"}\n    - {name: inflation_layer, type: "nav2_costmap_2d::InflationLayer"}\n\n# Obstacle layer configuration\nobstacle_layer:\n  enabled: true\n  observation_sources: scan\n  scan:\n    topic: /scan\n    max_obstacle_height: 2.0\n    clearing: true\n    marking: true\n    data_type: LaserScan\n    raytrace_max_range: 3.0\n    raytrace_min_range: 0.0\n    obstacle_max_range: 2.5\n    obstacle_min_range: 0.0\n\n# Inflation layer configuration\ninflation_layer:\n  enabled: true\n  cost_scaling_factor: 10.0\n  inflation_radius: 0.55\n'})}),"\n",(0,t.jsx)(e.h3,{id:"path-planning-algorithm-example",children:"Path Planning Algorithm Example"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'import numpy as np\nimport heapq\n\nclass AStarPlanner:\n    def __init__(self, occupancy_grid, resolution=0.05):\n        self.grid = occupancy_grid  # 2D array with 0=free, 1=occupied\n        self.resolution = resolution\n\n    def heuristic(self, pos1, pos2):\n        """Calculate heuristic distance (Manhattan distance)"""\n        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])\n\n    def get_neighbors(self, pos):\n        """Get valid neighbors of a position"""\n        neighbors = []\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue  # Skip current position\n\n                new_pos = (pos[0] + dx, pos[1] + dy)\n\n                # Check bounds\n                if (0 <= new_pos[0] < self.grid.shape[0] and\n                    0 <= new_pos[1] < self.grid.shape[1]):\n\n                    # Check if cell is free\n                    if self.grid[new_pos[0], new_pos[1]] == 0:\n                        neighbors.append(new_pos)\n\n        return neighbors\n\n    def plan_path(self, start, goal):\n        """Plan path using A* algorithm"""\n        # Priority queue: (cost, position)\n        open_set = [(0, start)]\n        came_from = {}\n\n        # Costs\n        g_score = {start: 0}\n        f_score = {start: self.heuristic(start, goal)}\n\n        while open_set:\n            current_cost, current = heapq.heappop(open_set)\n\n            if current == goal:\n                # Reconstruct path\n                path = [current]\n                while current in came_from:\n                    current = came_from[current]\n                    path.append(current)\n                path.reverse()\n                return path\n\n            for neighbor in self.get_neighbors(current):\n                tentative_g_score = g_score[current] + 1  # Assuming uniform cost\n\n                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + self.heuristic(neighbor, goal)\n\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n        return None  # No path found\n\n# Example usage\ndef example_usage():\n    # Create a simple occupancy grid (10x10, with some obstacles)\n    grid = np.zeros((10, 10))\n    grid[3, 3:7] = 1  # Horizontal obstacle\n    grid[5:8, 5] = 1  # Vertical obstacle\n\n    planner = AStarPlanner(grid)\n    path = planner.plan_path((0, 0), (9, 9))\n\n    if path:\n        print("Path found:", path)\n    else:\n        print("No path found")\n'})}),"\n",(0,t.jsx)(e.h2,{id:"urdf-examples",children:"URDF Examples"}),"\n",(0,t.jsx)(e.h3,{id:"robot-with-navigation-sensors",children:"Robot with Navigation Sensors"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="navigation_robot">\n  \x3c!-- Base Link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.3" length="0.15"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.3" length="0.15"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="10.0"/>\n      <inertia ixx="0.4" ixy="0.0" ixz="0.0" iyy="0.4" iyz="0.0" izz="0.2"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Wheels --\x3e\n  <joint name="wheel_left_joint" type="continuous">\n    <parent link="base_link"/>\n    <child link="wheel_left"/>\n    <origin xyz="0 0.25 -0.05" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n  </joint>\n\n  <link name="wheel_left">\n    <visual>\n      <geometry>\n        <cylinder radius="0.1" length="0.05"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0 0 0 1"/>\n      </material>\n    </visual>\n  </link>\n\n  <joint name="wheel_right_joint" type="continuous">\n    <parent link="base_link"/>\n    <child link="wheel_right"/>\n    <origin xyz="0 -0.25 -0.05" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n  </joint>\n\n  <link name="wheel_right">\n    <visual>\n      <geometry>\n        <cylinder radius="0.1" length="0.05"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0 0 0 1"/>\n      </material>\n    </visual>\n  </link>\n\n  \x3c!-- LIDAR Mount --\x3e\n  <joint name="lidar_mount_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="lidar_link"/>\n    <origin xyz="0.0 0.0 0.2" rpy="0 0 0"/>\n  </joint>\n\n  <link name="lidar_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.05" length="0.05"/>\n      </geometry>\n    </visual>\n  </link>\n\n  \x3c!-- IMU Mount --\x3e\n  <joint name="imu_mount_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="imu_link"/>\n    <origin xyz="0.0 0.0 0.1" rpy="0 0 0"/>\n  </joint>\n\n  <link name="imu_link"/>\n\n  \x3c!-- Navigation Sensors --\x3e\n  <gazebo reference="lidar_link">\n    <sensor name="lidar" type="ray">\n      <always_on>true</always_on>\n      <update_rate>10</update_rate>\n      <ray>\n        <scan>\n          <horizontal>\n            <samples>360</samples>\n            <resolution>1.0</resolution>\n            <min_angle>-3.14159</min_angle>\n            <max_angle>3.14159</max_angle>\n          </horizontal>\n        </scan>\n        <range>\n          <min>0.1</min>\n          <max>10.0</max>\n          <resolution>0.01</resolution>\n        </range>\n      </ray>\n      <plugin name="lidar_controller" filename="libgazebo_ros_ray_sensor.so">\n        <frame_name>lidar_link</frame_name>\n        <topic_name>scan</topic_name>\n      </plugin>\n    </sensor>\n  </gazebo>\n\n  <gazebo reference="imu_link">\n    <sensor name="imu" type="imu">\n      <always_on>true</always_on>\n      <update_rate>100</update_rate>\n      <plugin name="imu_controller" filename="libgazebo_ros_imu.so">\n        <frame_name>imu_link</frame_name>\n        <topic_name>imu</topic_name>\n      </plugin>\n    </sensor>\n  </gazebo>\n\n  \x3c!-- Differential Drive Controller --\x3e\n  <gazebo>\n    <plugin name="diff_drive" filename="libgazebo_ros_diff_drive.so">\n      <left_joint>wheel_left_joint</left_joint>\n      <right_joint>wheel_right_joint</right_joint>\n      <wheel_separation>0.5</wheel_separation>\n      <wheel_diameter>0.2</wheel_diameter>\n      <command_topic>cmd_vel</command_topic>\n      <odometry_topic>odom</odometry_topic>\n      <odometry_frame>odom</odometry_frame>\n      <robot_base_frame>base_link</robot_base_frame>\n    </plugin>\n  </gazebo>\n</robot>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"kinematics-diagrams",children:"Kinematics Diagrams"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-mermaid",children:"graph TD\n    A[Map] --\x3e B[Global Planner]\n    B --\x3e C[Path]\n    C --\x3e D[Local Planner]\n    D --\x3e E[Velocity Commands]\n    E --\x3e F[Robot]\n    F --\x3e G[Odometry]\n    G --\x3e H[Local Costmap]\n    H --\x3e D\n    F --\x3e I[Laser Scan]\n    I --\x3e J[Global Costmap]\n    J --\x3e B\n\n    style A fill:#ff9999\n    style F fill:#99ccff\n    style C fill:#99ff99\n"})}),"\n",(0,t.jsx)(e.h2,{id:"navigation-hardware-configuration",children:"Navigation Hardware Configuration"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Component"}),(0,t.jsx)(e.th,{children:"Model"}),(0,t.jsx)(e.th,{children:"Interface"}),(0,t.jsx)(e.th,{children:"Purpose"}),(0,t.jsx)(e.th,{children:"Accuracy"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"LIDAR"}),(0,t.jsx)(e.td,{children:"Hokuyo UST-10LX"}),(0,t.jsx)(e.td,{children:"Ethernet"}),(0,t.jsx)(e.td,{children:"Obstacle detection"}),(0,t.jsx)(e.td,{children:"Range: \xb120mm"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"IMU"}),(0,t.jsx)(e.td,{children:"Microstrain 3DM-GX5-25"}),(0,t.jsx)(e.td,{children:"RS-485"}),(0,t.jsx)(e.td,{children:"Orientation & acceleration"}),(0,t.jsx)(e.td,{children:"Accel: \xb10.05m/s\xb2"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Wheel Encoders"}),(0,t.jsx)(e.td,{children:"Incremental Optical"}),(0,t.jsx)(e.td,{children:"Quadrature"}),(0,t.jsx)(e.td,{children:"Odometry"}),(0,t.jsx)(e.td,{children:"Resolution: 1000 PPR"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Camera"}),(0,t.jsx)(e.td,{children:"Intel RealSense D435"}),(0,t.jsx)(e.td,{children:"USB 3.0"}),(0,t.jsx)(e.td,{children:"Visual navigation"}),(0,t.jsx)(e.td,{children:"Depth: \xb12mm"})]})]})]}),"\n",(0,t.jsx)(e.h2,{id:"key-terms",children:"Key Terms"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"AMCL"}),": Adaptive Monte Carlo Localization - probabilistic localization algorithm"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Costmap"}),": Grid-based representation of obstacles and costs for navigation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Path Planning"}),": Algorithmic process of finding a safe path from start to goal"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Global Planner"}),": Computes optimal path considering static obstacles"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Local Planner"}),": Executes path following with dynamic obstacle avoidance"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"TF"}),": Transform Framework - coordinate transformation system"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"SLAM"}),": Simultaneous Localization and Mapping"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"learning-checkpoints",children:"Learning Checkpoints"}),"\n",(0,t.jsx)(e.h3,{id:"quiz-questions",children:"Quiz Questions"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"What is the main difference between global and local planners?"}),"\n",(0,t.jsx)(e.li,{children:"Name three path planning algorithms and their characteristics."}),"\n",(0,t.jsx)(e.li,{children:"How does AMCL differ from other localization methods?"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"practical-exercise",children:"Practical Exercise"}),"\n",(0,t.jsx)(e.p,{children:"Create a navigation configuration for your robot and plan a path from one corner of a room to another, avoiding obstacles."}),"\n",(0,t.jsx)(e.h2,{id:"hands-on-exercise",children:"Hands-On Exercise"}),"\n",(0,t.jsx)(e.p,{children:"Implement a simple A* path planning algorithm that works with an occupancy grid map. Visualize the resulting path and compare it to the shortest possible path."}),"\n",(0,t.jsx)(e.h2,{id:"personalization",children:"Personalization"}),"\n",(0,t.jsxs)("div",{className:"personalization-options",children:[(0,t.jsx)("h3",{children:"Adjust Learning Path:"}),(0,t.jsx)("button",{onClick:()=>setDifficulty("beginner"),children:"Beginner"}),(0,t.jsx)("button",{onClick:()=>setDifficulty("intermediate"),children:"Intermediate"}),(0,t.jsx)("button",{onClick:()=>setDifficulty("advanced"),children:"Advanced"})]}),"\n",(0,t.jsx)(e.h2,{id:"translation",children:"Translation"}),"\n",(0,t.jsx)("div",{className:"translation-controls",children:(0,t.jsx)("button",{onClick:()=>translateToUrdu(),children:"\u0627\u0631\u062f\u0648 \u0645\u06cc\u06ba \u062a\u0631\u062c\u0645\u06c1 \u06a9\u0631\u06cc\u06ba"})})]})}function h(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,a)=>{a.d(e,{R:()=>r,x:()=>l});var i=a(6540);const t={},o=i.createContext(t);function r(n){const e=i.useContext(o);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:r(n.components),i.createElement(o.Provider,{value:e},n.children)}}}]);