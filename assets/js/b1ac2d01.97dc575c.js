"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[6375],{7282:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"weekly-breakdown/week9/index","title":"Week 9 - Control Systems for Robotics","description":"Learning Objectives","source":"@site/docs/weekly-breakdown/week9/index.mdx","sourceDirName":"weekly-breakdown/week9","slug":"/weekly-breakdown/week9/","permalink":"/physical-ai-book/docs/weekly-breakdown/week9/","draft":false,"unlisted":false,"editUrl":"https://github.com/fatima317/physical-ai-book/tree/main/docs/weekly-breakdown/week9/index.mdx","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9,"title":"Week 9 - Control Systems for Robotics"},"sidebar":"tutorialSidebar","previous":{"title":"Week 8 - Manipulation and Grasping","permalink":"/physical-ai-book/docs/weekly-breakdown/week8/"},"next":{"title":"Week 10 - Perception and Sensor Fusion","permalink":"/physical-ai-book/docs/weekly-breakdown/week10/"}}');var i=t(4848),o=t(8453);const a={sidebar_position:9,title:"Week 9 - Control Systems for Robotics"},l="Week 9 - Control Systems for Robotics",s={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Control Systems in Robotics",id:"control-systems-in-robotics",level:2},{value:"Code Snippets",id:"code-snippets",level:2},{value:"PID Controller Implementation",id:"pid-controller-implementation",level:3},{value:"Advanced Control Strategies",id:"advanced-control-strategies",level:3},{value:"Trajectory Following Controller",id:"trajectory-following-controller",level:3},{value:"URDF Examples",id:"urdf-examples",level:2},{value:"Robot with Control Systems",id:"robot-with-control-systems",level:3},{value:"Control Systems Pipeline Diagram",id:"control-systems-pipeline-diagram",level:2},{value:"Control Strategies Comparison",id:"control-strategies-comparison",level:2},{value:"Key Terms",id:"key-terms",level:2},{value:"Learning Checkpoints",id:"learning-checkpoints",level:2},{value:"Quiz Questions",id:"quiz-questions",level:3},{value:"Practical Exercise",id:"practical-exercise",level:3},{value:"Hands-On Exercise",id:"hands-on-exercise",level:2},{value:"Personalization",id:"personalization",level:2},{value:"Translation",id:"translation",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"week-9---control-systems-for-robotics",children:"Week 9 - Control Systems for Robotics"})}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this week, you will be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement PID controllers for robot motion control"}),"\n",(0,i.jsx)(n.li,{children:"Design feedback control systems for stability and accuracy"}),"\n",(0,i.jsx)(n.li,{children:"Apply modern control theory to robotic systems"}),"\n",(0,i.jsx)(n.li,{children:"Implement adaptive and robust control strategies"}),"\n",(0,i.jsx)(n.li,{children:"Integrate control systems with sensor feedback"}),"\n",(0,i.jsx)(n.li,{children:"Tune control parameters for optimal performance"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"control-systems-in-robotics",children:"Control Systems in Robotics"}),"\n",(0,i.jsx)(n.p,{children:"Control systems are essential for enabling robots to perform precise and stable movements. They use feedback from sensors to adjust actuator commands and achieve desired behaviors. Key control concepts include:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feedback Control"}),": Using sensor measurements to adjust control commands"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stability"}),": Ensuring the system remains bounded and converges to desired states"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Accuracy"}),": Achieving desired positions, velocities, or forces"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Robustness"}),": Maintaining performance despite disturbances and uncertainties"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Adaptability"}),": Adjusting to changing conditions or parameters"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"code-snippets",children:"Code Snippets"}),"\n",(0,i.jsx)(n.h3,{id:"pid-controller-implementation",children:"PID Controller Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import numpy as np\nimport time\nfrom typing import Tuple, Optional\n\nclass PIDController:\n    def __init__(self, kp: float, ki: float, kd: float, dt: float = 0.01):\n        """\n        Initialize PID controller\n\n        Args:\n            kp: Proportional gain\n            ki: Integral gain\n            kd: Derivative gain\n            dt: Time step for integration\n        """\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n        self.dt = dt\n\n        # Internal state\n        self.prev_error = 0.0\n        self.integral = 0.0\n        self.setpoint = 0.0\n        self.last_time = time.time()\n\n    def update(self, current_value: float, setpoint: float = None) -> float:\n        """\n        Update PID controller and return control output\n\n        Args:\n            current_value: Current measured value\n            setpoint: Desired value (optional, can be set separately)\n\n        Returns:\n            Control output\n        """\n        if setpoint is not None:\n            self.setpoint = setpoint\n\n        current_time = time.time()\n        dt = current_time - self.last_time\n\n        # If dt is too small, use the configured dt\n        if dt < 1e-6:\n            dt = self.dt\n\n        # Calculate error\n        error = self.setpoint - current_value\n\n        # Proportional term\n        proportional = self.kp * error\n\n        # Integral term (accumulate error over time)\n        self.integral += error * dt\n        integral = self.ki * self.integral\n\n        # Derivative term (rate of change of error)\n        derivative = self.kd * (error - self.prev_error) / dt\n\n        # Calculate output\n        output = proportional + integral + derivative\n\n        # Store values for next iteration\n        self.prev_error = error\n        self.last_time = current_time\n\n        return output\n\n    def reset(self):\n        """Reset internal state"""\n        self.prev_error = 0.0\n        self.integral = 0.0\n        self.setpoint = 0.0\n        self.last_time = time.time()\n\n    def set_tunings(self, kp: float, ki: float, kd: float):\n        """Update PID tunings"""\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n\nclass RobotMotionController:\n    def __init__(self):\n        # PID controllers for linear and angular motion\n        self.linear_pid = PIDController(kp=1.0, ki=0.1, kd=0.05, dt=0.01)\n        self.angular_pid = PIDController(kp=2.0, ki=0.2, kd=0.1, dt=0.01)\n\n        # Robot parameters\n        self.max_linear_vel = 1.0  # m/s\n        self.max_angular_vel = 1.0  # rad/s\n        self.wheel_separation = 0.5  # meters\n\n    def control_to_pose(self, current_pose, target_pose, dt=0.01):\n        """\n        Calculate control commands to move robot to target pose\n\n        Args:\n            current_pose: [x, y, theta] current robot pose\n            target_pose: [x, y, theta] target robot pose\n            dt: Time step\n\n        Returns:\n            [linear_vel, angular_vel] control commands\n        """\n        x_curr, y_curr, theta_curr = current_pose\n        x_target, y_target, theta_target = target_pose\n\n        # Calculate distance and angle to target\n        dx = x_target - x_curr\n        dy = y_target - y_curr\n        distance = np.sqrt(dx**2 + dy**2)\n\n        # Calculate angle to target\n        angle_to_target = np.arctan2(dy, dx)\n        angle_error = angle_to_target - theta_curr\n\n        # Normalize angle error to [-pi, pi]\n        while angle_error > np.pi:\n            angle_error -= 2 * np.pi\n        while angle_error < -np.pi:\n            angle_error += 2 * np.pi\n\n        # Setpoint for angular velocity (rotate to face target)\n        angular_setpoint = angle_error\n\n        # Calculate linear velocity based on distance\n        linear_setpoint = min(distance, self.max_linear_vel)\n\n        # Update PID controllers\n        angular_cmd = self.angular_pid.update(0.0, angular_setpoint)\n        linear_cmd = self.linear_pid.update(0.0, linear_setpoint)\n\n        # Apply limits\n        angular_cmd = np.clip(angular_cmd, -self.max_angular_vel, self.max_angular_vel)\n        linear_cmd = np.clip(linear_cmd, -self.max_linear_vel, self.max_linear_vel)\n\n        return linear_cmd, angular_cmd\n\n# Example usage\ndef example_pid_control():\n    controller = RobotMotionController()\n\n    # Simulate robot moving to target\n    current_pose = [0.0, 0.0, 0.0]  # Start at origin facing x-axis\n    target_pose = [2.0, 1.0, 0.0]   # Target at (2,1), facing x-axis\n\n    print("Time\\tX\\tY\\tTheta\\tLinear_Vel\\tAngular_Vel")\n\n    for t in np.arange(0, 10, 0.1):  # 10 seconds of simulation\n        linear_vel, angular_vel = controller.control_to_pose(current_pose, target_pose)\n\n        # Simple kinematic model update\n        dt = 0.1\n        x, y, theta = current_pose\n        x += linear_vel * np.cos(theta) * dt\n        y += linear_vel * np.sin(theta) * dt\n        theta += angular_vel * dt\n\n        current_pose = [x, y, theta]\n\n        print(f"{t:.1f}\\t{x:.2f}\\t{y:.2f}\\t{theta:.2f}\\t{linear_vel:.2f}\\t{angular_vel:.2f}")\n\n        # Check if close enough to target\n        dist_to_target = np.sqrt((x - target_pose[0])**2 + (y - target_pose[1])**2)\n        if dist_to_target < 0.1:  # Within 10cm of target\n            print(f"Reached target at time {t:.1f}s")\n            break\n'})}),"\n",(0,i.jsx)(n.h3,{id:"advanced-control-strategies",children:"Advanced Control Strategies"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom scipy.linalg import solve_continuous_are\nfrom scipy.signal import lti, step\n\nclass LinearQuadraticRegulator:\n    """\n    Linear Quadratic Regulator (LQR) for optimal control\n    """\n    def __init__(self, A, B, Q, R):\n        """\n        Initialize LQR controller\n\n        Args:\n            A: State matrix (nxn)\n            B: Input matrix (nxm)\n            Q: State cost matrix (nxn)\n            R: Input cost matrix (mxm)\n        """\n        self.A = np.array(A)\n        self.B = np.array(B)\n        self.Q = np.array(Q)\n        self.R = np.array(R)\n        self.n = A.shape[0]  # State dimension\n        self.m = B.shape[1]  # Input dimension\n\n        # Solve Riccati equation to find optimal gain\n        self.P = solve_continuous_are(self.A, self.B, self.Q, self.R)\n\n        # Calculate optimal feedback gain: u = -K*x\n        self.K = np.linalg.inv(self.R) @ self.B.T @ self.P\n\n    def control(self, state):\n        """Calculate control input for given state"""\n        return -self.K @ state\n\n    def get_gain(self):\n        """Return the feedback gain matrix"""\n        return self.K\n\nclass AdaptiveController:\n    """\n    Adaptive controller that adjusts parameters based on system behavior\n    """\n    def __init__(self, initial_params, learning_rate=0.01):\n        self.params = np.array(initial_params)\n        self.learning_rate = learning_rate\n        self.error_history = []\n\n    def update_params(self, state, error, dt=0.01):\n        """\n        Update controller parameters based on error\n        """\n        # Store error for adaptation\n        self.error_history.append(error)\n\n        # Keep only recent errors (last 100)\n        if len(self.error_history) > 100:\n            self.error_history.pop(0)\n\n        # Simple parameter adaptation based on accumulated error\n        if len(self.error_history) > 10:\n            # Calculate average error magnitude\n            avg_error = np.mean(np.abs(self.error_history[-10:]))\n\n            # Adjust parameters based on error trend\n            if avg_error > 0.1:  # If error is too large\n                # Increase gains slightly\n                self.params *= (1 + self.learning_rate * avg_error)\n            elif avg_error < 0.01:  # If error is very small\n                # Decrease gains to avoid oscillation\n                self.params *= (1 - self.learning_rate * 0.5)\n\n    def control(self, state, error):\n        """Calculate control based on adapted parameters"""\n        # Simple example: scaled error-based control\n        return self.params * error\n\nclass ModelPredictiveController:\n    """\n    Simplified Model Predictive Controller\n    """\n    def __init__(self, A, B, Q, R, horizon=10):\n        """\n        Initialize MPC controller\n\n        Args:\n            A, B: System matrices (state-space model)\n            Q, R: Cost matrices\n            horizon: Prediction horizon\n        """\n        self.A = np.array(A)\n        self.B = np.array(B)\n        self.Q = np.array(Q)\n        self.R = np.array(R)\n        self.horizon = horizon\n        self.n = A.shape[0]  # State dimension\n        self.m = B.shape[1]  # Input dimension\n\n    def predict_trajectory(self, initial_state, control_sequence):\n        """\n        Predict state trajectory given control sequence\n        """\n        states = [initial_state]\n        current_state = initial_state.copy()\n\n        for u in control_sequence:\n            # x_{k+1} = A*x_k + B*u_k\n            next_state = self.A @ current_state + self.B @ u\n            states.append(next_state)\n            current_state = next_state\n\n        return np.array(states)\n\n    def calculate_cost(self, state_trajectory, control_trajectory):\n        """\n        Calculate total cost of trajectory\n        """\n        total_cost = 0\n\n        # State cost\n        for state in state_trajectory[:-1]:  # Exclude final state\n            total_cost += state.T @ self.Q @ state\n\n        # Control cost\n        for control in control_trajectory:\n            total_cost += control.T @ self.R @ control\n\n        return total_cost\n\n    def control(self, current_state):\n        """\n        Calculate optimal control input using simplified optimization\n        """\n        # For simplicity, use gradient descent approach\n        # In practice, this would use more sophisticated optimization\n\n        # Initial guess for control sequence\n        control_seq = np.zeros((self.horizon, self.m))\n\n        # Simplified approach: use LQR solution as approximation\n        # Solve Riccati equation for LQR gain\n        P = solve_continuous_are(self.A, self.B, self.Q, self.R)\n        K = np.linalg.inv(self.R) @ self.B.T @ P\n\n        # Return LQR control as approximation\n        return -K @ current_state\n\n# Example: Controlling a simple robot with different controllers\ndef example_advanced_control():\n    # System matrices for a simple 2nd-order system (position, velocity)\n    A = np.array([[0, 1],\n                   [0, -1]])  # Damped system: m*\u1e8d + c*\u1e8b = u\n    B = np.array([[0],\n                  [1]])      # Input affects acceleration\n    Q = np.array([[1, 0],    # Penalize position error\n                  [0, 0.1]]) # Penalize velocity error\n    R = np.array([[0.01]])   # Penalize control effort\n\n    # Initialize controllers\n    lqr = LinearQuadraticRegulator(A, B, Q, R)\n    mpc = ModelPredictiveController(A, B, Q, R, horizon=5)\n    adaptive = AdaptiveController([1.0, 1.0])\n\n    # Simulate system response\n    dt = 0.01\n    time_steps = 1000\n    state = np.array([1.0, 0.0])  # Start with position=1, velocity=0\n    target = np.array([0.0, 0.0])  # Want to reach origin\n\n    print("Time\\tPosition\\tVelocity\\tLQR_Control")\n\n    for i in range(time_steps):\n        t = i * dt\n\n        # Calculate control using LQR\n        control = lqr.control(state)\n\n        # Update system: \u1e8b = Ax + Bu\n        state_dot = A @ state + B @ control[0]  # Extract scalar from 1x1 array\n        state = state + state_dot * dt\n\n        if i % 100 == 0:  # Print every 100 steps\n            print(f"{t:.2f}\\t{state[0]:.3f}\\t\\t{state[1]:.3f}\\t\\t{control[0]:.3f}")\n\n        # Update adaptive controller\n        error = target - state\n        adaptive.update_params(state, np.linalg.norm(error), dt)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"trajectory-following-controller",children:"Trajectory Following Controller"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom scipy.interpolate import interp1d\n\nclass TrajectoryFollower:\n    """\n    Controller that follows a predefined trajectory with feedback\n    """\n    def __init__(self, kp_pos=2.0, kp_vel=1.0, ki_pos=0.01, dt=0.01):\n        self.kp_pos = kp_pos  # Position proportional gain\n        self.kp_vel = kp_vel  # Velocity proportional gain\n        self.ki_pos = ki_pos  # Position integral gain\n        self.dt = dt\n\n        # Trajectory tracking state\n        self.pos_integral = 0.0\n        self.trajectory = None\n        self.traj_time = 0.0\n\n    def set_trajectory(self, times, positions, velocities=None):\n        """\n        Set the trajectory to follow\n\n        Args:\n            times: Array of time points\n            positions: Array of position values\n            velocities: Array of velocity values (optional, will be computed if not provided)\n        """\n        self.traj_times = np.array(times)\n        self.traj_positions = np.array(positions)\n\n        if velocities is None:\n            # Compute velocities from position derivatives\n            dt_vals = np.diff(times)\n            dx_vals = np.diff(positions)\n            velocities = np.append(dx_vals / dt_vals, dx_vals[-1] / dt_vals[-1])  # Extrapolate last velocity\n\n        self.traj_velocities = np.array(velocities)\n\n        # Create interpolation functions\n        self.pos_interp = interp1d(times, positions, kind=\'cubic\', fill_value=\'extrapolate\')\n        self.vel_interp = interp1d(times, velocities, kind=\'cubic\', fill_value=\'extrapolate\')\n\n        self.traj_time = 0.0\n        self.pos_integral = 0.0\n\n    def update(self, current_pos, current_vel, dt=None):\n        """\n        Update controller and return control command\n\n        Args:\n            current_pos: Current position\n            current_vel: Current velocity\n            dt: Time step (uses default if not provided)\n\n        Returns:\n            Control command\n        """\n        if dt is None:\n            dt = self.dt\n\n        # Get desired state at current time\n        desired_pos = float(self.pos_interp(self.traj_time))\n        desired_vel = float(self.vel_interp(self.traj_time))\n\n        # Calculate errors\n        pos_error = desired_pos - current_pos\n        vel_error = desired_vel - current_vel\n\n        # Update position integral\n        self.pos_integral += pos_error * dt\n\n        # Calculate control using PD + I control\n        control = (self.kp_pos * pos_error +\n                  self.kp_vel * vel_error +\n                  self.ki_pos * self.pos_integral)\n\n        # Update trajectory time\n        self.traj_time += dt\n\n        return control\n\nclass CartesianImpedanceController:\n    """\n    Impedance controller for Cartesian space control\n    """\n    def __init__(self, stiffness=1000, damping_ratio=1.0, dt=0.01):\n        """\n        Initialize impedance controller\n\n        Args:\n            stiffness: Spring constant (N/m)\n            damping_ratio: Damping ratio (1.0 = critically damped)\n            dt: Time step\n        """\n        self.stiffness = stiffness\n        self.damping_ratio = damping_ratio\n        self.dt = dt\n\n        # Calculate damping coefficient for critical damping\n        self.damping = 2 * damping_ratio * np.sqrt(stiffness)\n\n        # State tracking\n        self.prev_force = np.zeros(3)\n        self.prev_error = np.zeros(3)\n\n    def control(self, current_pose, desired_pose, current_vel=None, desired_vel=None):\n        """\n        Calculate control force based on Cartesian position error\n\n        Args:\n            current_pose: Current position [x, y, z]\n            desired_pose: Desired position [x, y, z]\n            current_vel: Current velocity (optional)\n            desired_vel: Desired velocity (optional)\n\n        Returns:\n            Force command [fx, fy, fz]\n        """\n        current_pose = np.array(current_pose)\n        desired_pose = np.array(desired_pose)\n\n        if current_vel is None:\n            current_vel = np.zeros(3)\n        if desired_vel is None:\n            desired_vel = np.zeros(3)\n\n        # Calculate position and velocity errors\n        pos_error = desired_pose - current_pose\n        vel_error = desired_vel - current_vel\n\n        # Calculate impedance force: F = K * error + D * velocity_error\n        force = self.stiffness * pos_error + self.damping * vel_error\n\n        return force\n\n# Example usage\ndef example_trajectory_control():\n    # Create a circular trajectory\n    times = np.linspace(0, 10, 1000)\n    radius = 1.0\n    omega = 0.5  # rad/s\n\n    # Circular motion: x = r*cos(\u03c9t), y = r*sin(\u03c9t)\n    x_traj = radius * np.cos(omega * times)\n    y_traj = radius * np.sin(omega * times)\n\n    # Velocities (derivatives)\n    vx_traj = -radius * omega * np.sin(omega * times)\n    vy_traj = radius * omega * omega * np.cos(omega * times)\n\n    # Combine into 2D trajectories\n    pos_traj = np.column_stack([x_traj, y_traj])\n    vel_traj = np.column_stack([vx_traj, vy_traj])\n\n    # Initialize trajectory follower\n    follower = TrajectoryFollower(kp_pos=5.0, kp_vel=2.0, ki_pos=0.1)\n\n    # Set the trajectory (using x-component as example)\n    follower.set_trajectory(times, x_traj, vx_traj)\n\n    # Simulate following the trajectory\n    current_pos = 0.0\n    current_vel = 0.0\n    mass = 1.0  # kg\n\n    print("Time\\tDes_Pos\\tCur_Pos\\tError\\tControl")\n\n    for i, t in enumerate(times):\n        if i > 0 and i % 100 == 0:  # Print every 100 steps\n            desired_pos = float(follower.pos_interp(follower.traj_time))\n            pos_error = desired_pos - current_pos\n            print(f"{t:.2f}\\t{desired_pos:.3f}\\t{current_pos:.3f}\\t{pos_error:.3f}\\t{control:.3f}")\n\n        # Calculate control\n        control = follower.update(current_pos, current_vel)\n\n        # Apply control (simple mass model: \u1e8d = F/m)\n        acceleration = control / mass\n\n        # Update state\n        current_vel += acceleration * follower.dt\n        current_pos += current_vel * follower.dt\n'})}),"\n",(0,i.jsx)(n.h2,{id:"urdf-examples",children:"URDF Examples"}),"\n",(0,i.jsx)(n.h3,{id:"robot-with-control-systems",children:"Robot with Control Systems"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="controlled_robot">\n  \x3c!-- Base Link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.2" length="0.1"/>\n      </geometry>\n      <material name="dark_gray">\n        <color rgba="0.3 0.3 0.3 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.2" length="0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="5.0"/>\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.05"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Wheel Links --\x3e\n  <link name="wheel_left">\n    <visual>\n      <geometry>\n        <cylinder radius="0.1" length="0.05"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0.0 0.0 0.0 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.1" length="0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.005" ixy="0.0" ixz="0.0" iyy="0.005" iyz="0.0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  <link name="wheel_right">\n    <visual>\n      <geometry>\n        <cylinder radius="0.1" length="0.05"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0.0 0.0 0.0 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.1" length="0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.005" ixy="0.0" ixz="0.0" iyy="0.005" iyz="0.0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Wheel Joints --\x3e\n  <joint name="wheel_left_joint" type="continuous">\n    <parent link="base_link"/>\n    <child link="wheel_left"/>\n    <origin xyz="0 0.2 -0.05" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <dynamics damping="0.1" friction="0.0"/>\n  </joint>\n\n  <joint name="wheel_right_joint" type="continuous">\n    <parent link="base_link"/>\n    <child link="wheel_right"/>\n    <origin xyz="0 -0.2 -0.05" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <dynamics damping="0.1" friction="0.0"/>\n  </joint>\n\n  \x3c!-- Manipulator Arm Base --\x3e\n  <joint name="arm_base_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="arm_base"/>\n    <origin xyz="0.1 0 0.1" rpy="0 0 0"/>\n  </joint>\n\n  <link name="arm_base">\n    <visual>\n      <geometry>\n        <cylinder radius="0.05" length="0.1"/>\n      </geometry>\n      <material name="silver">\n        <color rgba="0.7 0.7 0.7 1.0"/>\n      </material>\n    </visual>\n  </link>\n\n  \x3c!-- Arm Joints and Links --\x3e\n  <joint name="shoulder_joint" type="revolute">\n    <parent link="arm_base"/>\n    <child link="upper_arm"/>\n    <origin xyz="0 0 0.05" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="1.0"/>\n    <dynamics damping="1.0" friction="0.1"/>\n  </joint>\n\n  <link name="upper_arm">\n    <visual>\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n      <material name="steel">\n        <color rgba="0.5 0.5 0.5 1.0"/>\n      </material>\n    </visual>\n    <inertial>\n      <mass value="2.0"/>\n      <inertia ixx="0.02" ixy="0.0" ixz="0.0" iyy="0.02" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  <joint name="elbow_joint" type="revolute">\n    <parent link="upper_arm"/>\n    <child link="forearm"/>\n    <origin xyz="0 0 0.3" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="1.0"/>\n    <dynamics damping="1.0" friction="0.1"/>\n  </joint>\n\n  <link name="forearm">\n    <visual>\n      <geometry>\n        <cylinder radius="0.03" length="0.25"/>\n      </geometry>\n      <material name="steel">\n        <color rgba="0.5 0.5 0.5 1.0"/>\n      </material>\n    </visual>\n    <inertial>\n      <mass value="1.5"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.0008"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Gripper --\x3e\n  <joint name="wrist_joint" type="revolute">\n    <parent link="forearm"/>\n    <child link="wrist"/>\n    <origin xyz="0 0 0.25" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="-3.14" upper="3.14" effort="50" velocity="2.0"/>\n    <dynamics damping="0.5" friction="0.05"/>\n  </joint>\n\n  <link name="wrist">\n    <visual>\n      <geometry>\n        <sphere radius="0.03"/>\n      </geometry>\n      <material name="aluminum">\n        <color rgba="0.8 0.8 0.8 1.0"/>\n      </material>\n    </visual>\n  </link>\n\n  \x3c!-- Gazebo Controllers --\x3e\n  <gazebo>\n    <plugin name="diff_drive" filename="libgazebo_ros_diff_drive.so">\n      <left_joint>wheel_left_joint</left_joint>\n      <right_joint>wheel_right_joint</right_joint>\n      <wheel_separation>0.4</wheel_separation>\n      <wheel_diameter>0.2</wheel_diameter>\n      <command_topic>cmd_vel</command_topic>\n      <odometry_topic>odom</odometry_topic>\n      <odometry_frame>odom</odometry_frame>\n      <robot_base_frame>base_link</robot_base_frame>\n      <publish_odom>true</publish_odom>\n      <publish_odom_tf>true</publish_odom_tf>\n      <publish_wheel_tf>true</publish_wheel_tf>\n    </plugin>\n  </gazebo>\n\n  \x3c!-- Arm Controller --\x3e\n  <gazebo>\n    <plugin name="arm_controller" filename="libgazebo_ros_control.so">\n      <robotNamespace>/arm</robotNamespace>\n    </plugin>\n  </gazebo>\n\n  \x3c!-- Joint State Publisher --\x3e\n  <gazebo>\n    <plugin name="joint_state_publisher" filename="libgazebo_ros_joint_state_publisher.so">\n      <joint_name>shoulder_joint, elbow_joint, wrist_joint</joint_name>\n    </plugin>\n  </gazebo>\n\n  \x3c!-- PID Controllers for Joints --\x3e\n  <gazebo reference="shoulder_joint">\n    <implicitSpringDamper>1</implicitSpringDamper>\n  </gazebo>\n\n  <gazebo reference="elbow_joint">\n    <implicitSpringDamper>1</implicitSpringDamper>\n  </gazebo>\n\n  <gazebo reference="wrist_joint">\n    <implicitSpringDamper>1</implicitSpringDamper>\n  </gazebo>\n\n  \x3c!-- Control Transmissions --\x3e\n  <transmission name="shoulder_trans">\n    <type>transmission_interface/SimpleTransmission</type>\n    <joint name="shoulder_joint">\n      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>\n    </joint>\n    <actuator name="shoulder_motor">\n      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>\n      <mechanicalReduction>1</mechanicalReduction>\n    </actuator>\n  </transmission>\n\n  <transmission name="elbow_trans">\n    <type>transmission_interface/SimpleTransmission</type>\n    <joint name="elbow_joint">\n      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>\n    </joint>\n    <actuator name="elbow_motor">\n      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>\n      <mechanicalReduction>1</mechanicalReduction>\n    </actuator>\n  </transmission>\n\n  <transmission name="wrist_trans">\n    <type>transmission_interface/SimpleTransmission</type>\n    <joint name="wrist_joint">\n      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>\n    </joint>\n    <actuator name="wrist_motor">\n      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>\n      <mechanicalReduction>1</mechanicalReduction>\n    </actuator>\n  </transmission>\n</robot>\n'})}),"\n",(0,i.jsx)(n.h2,{id:"control-systems-pipeline-diagram",children:"Control Systems Pipeline Diagram"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    A[Reference Signal] --\x3e B[Controller]\n    B --\x3e C[Plant/Robot]\n    C --\x3e D[Output]\n    D --\x3e E[Sensors]\n    E --\x3e F[Feedback]\n    F --\x3e B\n    D --\x3e G[Performance Metrics]\n    G --\x3e H[Tuning]\n    H --\x3e B\n\n    style A fill:#ff9999\n    style B fill:#99ff99\n    style D fill:#99ccff\n"})}),"\n",(0,i.jsx)(n.h2,{id:"control-strategies-comparison",children:"Control Strategies Comparison"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Strategy"}),(0,i.jsx)(n.th,{children:"Response Speed"}),(0,i.jsx)(n.th,{children:"Stability"}),(0,i.jsx)(n.th,{children:"Robustness"}),(0,i.jsx)(n.th,{children:"Complexity"}),(0,i.jsx)(n.th,{children:"Best For"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"PID"}),(0,i.jsx)(n.td,{children:"Fast"}),(0,i.jsx)(n.td,{children:"Good"}),(0,i.jsx)(n.td,{children:"Moderate"}),(0,i.jsx)(n.td,{children:"Low"}),(0,i.jsx)(n.td,{children:"Basic positioning"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"LQR"}),(0,i.jsx)(n.td,{children:"Optimal"}),(0,i.jsx)(n.td,{children:"Excellent"}),(0,i.jsx)(n.td,{children:"Good"}),(0,i.jsx)(n.td,{children:"Medium"}),(0,i.jsx)(n.td,{children:"Linear systems"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"MPC"}),(0,i.jsx)(n.td,{children:"Good"}),(0,i.jsx)(n.td,{children:"Excellent"}),(0,i.jsx)(n.td,{children:"Excellent"}),(0,i.jsx)(n.td,{children:"High"}),(0,i.jsx)(n.td,{children:"Constrained systems"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Adaptive"}),(0,i.jsx)(n.td,{children:"Variable"}),(0,i.jsx)(n.td,{children:"Good"}),(0,i.jsx)(n.td,{children:"Excellent"}),(0,i.jsx)(n.td,{children:"High"}),(0,i.jsx)(n.td,{children:"Changing conditions"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Sliding Mode"}),(0,i.jsx)(n.td,{children:"Fast"}),(0,i.jsx)(n.td,{children:"Excellent"}),(0,i.jsx)(n.td,{children:"Excellent"}),(0,i.jsx)(n.td,{children:"Medium"}),(0,i.jsx)(n.td,{children:"Disturbances"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Fuzzy Logic"}),(0,i.jsx)(n.td,{children:"Variable"}),(0,i.jsx)(n.td,{children:"Good"}),(0,i.jsx)(n.td,{children:"Good"}),(0,i.jsx)(n.td,{children:"Medium"}),(0,i.jsx)(n.td,{children:"Uncertain systems"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"key-terms",children:"Key Terms"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PID Controller"}),": Proportional-Integral-Derivative controller for feedback control"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stability"}),": Property ensuring system remains bounded and converges to equilibrium"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Gain"}),": Parameter that determines controller sensitivity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feedback"}),": Using system output to adjust control input"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feedforward"}),": Using reference signal directly in control calculation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Riccati Equation"}),": Mathematical equation used in LQR design"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lyapunov Stability"}),": Mathematical framework for proving stability"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bode Plot"}),": Frequency response analysis tool"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"learning-checkpoints",children:"Learning Checkpoints"}),"\n",(0,i.jsx)(n.h3,{id:"quiz-questions",children:"Quiz Questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"What are the three components of a PID controller and their functions?"}),"\n",(0,i.jsx)(n.li,{children:"How does increasing the proportional gain affect system response?"}),"\n",(0,i.jsx)(n.li,{children:"What is the purpose of the integral term in PID control?"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"practical-exercise",children:"Practical Exercise"}),"\n",(0,i.jsx)(n.p,{children:"Implement a PID controller for a simulated robot and tune the parameters to achieve stable motion with minimal overshoot."}),"\n",(0,i.jsx)(n.h2,{id:"hands-on-exercise",children:"Hands-On Exercise"}),"\n",(0,i.jsx)(n.p,{children:"Create a ROS 2 node that implements a trajectory-following controller and test it with different reference trajectories (step, ramp, sinusoidal)."}),"\n",(0,i.jsx)(n.h2,{id:"personalization",children:"Personalization"}),"\n",(0,i.jsxs)("div",{className:"personalization-options",children:[(0,i.jsx)("h3",{children:"Adjust Learning Path:"}),(0,i.jsx)("button",{onClick:()=>setDifficulty("beginner"),children:"Beginner"}),(0,i.jsx)("button",{onClick:()=>setDifficulty("intermediate"),children:"Intermediate"}),(0,i.jsx)("button",{onClick:()=>setDifficulty("advanced"),children:"Advanced"})]}),"\n",(0,i.jsx)(n.h2,{id:"translation",children:"Translation"}),"\n",(0,i.jsx)("div",{className:"translation-controls",children:(0,i.jsx)("button",{onClick:()=>translateToUrdu(),children:"\u0627\u0631\u062f\u0648 \u0645\u06cc\u06ba \u062a\u0631\u062c\u0645\u06c1 \u06a9\u0631\u06cc\u06ba"})})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var r=t(6540);const i={},o=r.createContext(i);function a(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);