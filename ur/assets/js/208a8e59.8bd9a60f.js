"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[7243],{2635:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"weekly-breakdown/week8/index","title":"Week 8 - Manipulation and Grasping","description":"Learning Objectives","source":"@site/docs/weekly-breakdown/week8/index.mdx","sourceDirName":"weekly-breakdown/week8","slug":"/weekly-breakdown/week8/","permalink":"/physical-ai-book/ur/docs/weekly-breakdown/week8/","draft":false,"unlisted":false,"editUrl":"https://github.com/fatima317/physical-ai-book/tree/main/docs/weekly-breakdown/week8/index.mdx","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8,"title":"Week 8 - Manipulation and Grasping"},"sidebar":"tutorialSidebar","previous":{"title":"Week 7 - Human-Robot Interaction","permalink":"/physical-ai-book/ur/docs/weekly-breakdown/week7/"},"next":{"title":"Week 9 - Control Systems for Robotics","permalink":"/physical-ai-book/ur/docs/weekly-breakdown/week9/"}}');var a=i(4848),r=i(8453);const o={sidebar_position:8,title:"Week 8 - Manipulation and Grasping"},s="Week 8 - Manipulation and Grasping",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Manipulation Fundamentals",id:"manipulation-fundamentals",level:2},{value:"Code Snippets",id:"code-snippets",level:2},{value:"Forward and Inverse Kinematics",id:"forward-and-inverse-kinematics",level:3},{value:"Grasp Planning and Execution",id:"grasp-planning-and-execution",level:3},{value:"Vision-Based Object Recognition and Pose Estimation",id:"vision-based-object-recognition-and-pose-estimation",level:3},{value:"URDF Examples",id:"urdf-examples",level:2},{value:"Manipulator Robot with Gripper",id:"manipulator-robot-with-gripper",level:3},{value:"Manipulation Pipeline Diagram",id:"manipulation-pipeline-diagram",level:2},{value:"Manipulation Strategies Comparison",id:"manipulation-strategies-comparison",level:2},{value:"Key Terms",id:"key-terms",level:2},{value:"Learning Checkpoints",id:"learning-checkpoints",level:2},{value:"Quiz Questions",id:"quiz-questions",level:3},{value:"Practical Exercise",id:"practical-exercise",level:3},{value:"Hands-On Exercise",id:"hands-on-exercise",level:2},{value:"Personalization",id:"personalization",level:2},{value:"Translation",id:"translation",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"week-8---manipulation-and-grasping",children:"Week 8 - Manipulation and Grasping"})}),"\n",(0,a.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(e.p,{children:"By the end of this week, you will be able to:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Understand kinematics and dynamics of robotic manipulators"}),"\n",(0,a.jsx)(e.li,{children:"Implement inverse kinematics for arm control"}),"\n",(0,a.jsx)(e.li,{children:"Design grasping strategies for various objects"}),"\n",(0,a.jsx)(e.li,{children:"Integrate vision systems for object recognition and pose estimation"}),"\n",(0,a.jsx)(e.li,{children:"Plan collision-free trajectories for manipulation tasks"}),"\n",(0,a.jsx)(e.li,{children:"Implement compliant control for safe interaction"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"manipulation-fundamentals",children:"Manipulation Fundamentals"}),"\n",(0,a.jsx)(e.p,{children:"Robotic manipulation involves the precise control of robotic arms and grippers to grasp, move, and manipulate objects. Key components include:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Forward Kinematics"}),": Calculating end-effector position from joint angles"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Inverse Kinematics"}),": Calculating joint angles to reach desired end-effector position"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Grasp Planning"}),": Determining optimal grasp points and configurations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Trajectory Planning"}),": Generating smooth, collision-free paths"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Force Control"}),": Managing contact forces for safe interaction"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"code-snippets",children:"Code Snippets"}),"\n",(0,a.jsx)(e.h3,{id:"forward-and-inverse-kinematics",children:"Forward and Inverse Kinematics"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom scipy.spatial.transform import Rotation as R\nimport math\n\nclass ManipulatorKinematics:\n    def __init__(self, dh_parameters):\n        """\n        Initialize manipulator with Denavit-Hartenberg parameters\n        dh_parameters: list of [a, alpha, d, theta_offset] for each joint\n        """\n        self.dh_params = dh_parameters\n        self.num_joints = len(dh_params)\n\n    def dh_matrix(self, a, alpha, d, theta):\n        """Calculate Denavit-Hartenberg transformation matrix"""\n        return np.array([\n            [math.cos(theta), -math.sin(theta)*math.cos(alpha), math.sin(theta)*math.sin(alpha), a*math.cos(theta)],\n            [math.sin(theta), math.cos(theta)*math.cos(alpha), -math.cos(theta)*math.sin(alpha), a*math.sin(theta)],\n            [0, math.sin(alpha), math.cos(alpha), d],\n            [0, 0, 0, 1]\n        ])\n\n    def forward_kinematics(self, joint_angles):\n        """Calculate end-effector pose given joint angles"""\n        T = np.eye(4)  # Identity matrix\n\n        for i in range(self.num_joints):\n            a, alpha, d, theta_offset = self.dh_params[i]\n            theta = joint_angles[i] + theta_offset\n            T_i = self.dh_matrix(a, alpha, d, theta)\n            T = T @ T_i\n\n        # Extract position and orientation\n        position = T[:3, 3]\n        rotation_matrix = T[:3, :3]\n\n        # Convert rotation matrix to Euler angles (ZYX)\n        euler_angles = R.from_matrix(rotation_matrix).as_euler(\'xyz\')\n\n        return position, euler_angles, T\n\n    def jacobian(self, joint_angles):\n        """Calculate geometric Jacobian matrix"""\n        # Get transformation matrices for all joints\n        transforms = []\n        T_cumulative = np.eye(4)\n\n        for i in range(self.num_joints):\n            a, alpha, d, theta_offset = self.dh_params[i]\n            theta = joint_angles[i] + theta_offset\n            T_i = self.dh_matrix(a, alpha, d, theta)\n            T_cumulative = T_cumulative @ T_i\n            transforms.append(T_cumulative.copy())\n\n        # Get end-effector position\n        end_effector_pos = transforms[-1][:3, 3]\n\n        # Initialize Jacobian\n        J = np.zeros((6, self.num_joints))\n\n        # Calculate Jacobian columns\n        for i in range(self.num_joints):\n            # Z-axis of joint i in world coordinates\n            z_i = transforms[i][:3, 2]\n\n            # Position of joint i in world coordinates\n            p_i = transforms[i][:3, 3]\n\n            # Calculate position difference\n            diff = end_effector_pos - p_i\n\n            # Linear velocity contribution\n            J[:3, i] = np.cross(z_i, diff)\n\n            # Angular velocity contribution\n            J[3:, i] = z_i\n\n        return J\n\n    def inverse_kinematics(self, target_pose, initial_joints=None, max_iterations=100, tolerance=1e-4):\n        """Solve inverse kinematics using Jacobian transpose method"""\n        if initial_joints is None:\n            current_joints = np.zeros(self.num_joints)\n        else:\n            current_joints = np.array(initial_joints)\n\n        target_pos = target_pose[:3]\n        target_rot = R.from_euler(\'xyz\', target_pose[3:]).as_matrix()\n\n        for iteration in range(max_iterations):\n            # Calculate current end-effector pose\n            current_pos, current_rot_angles, current_transform = self.forward_kinematics(current_joints)\n            current_rot = R.from_euler(\'xyz\', current_rot_angles).as_matrix()\n\n            # Calculate position and orientation errors\n            pos_error = target_pos - current_pos\n            rot_error = target_rot.T @ current_rot - current_rot.T @ target_rot\n            # Simplified orientation error (skew-symmetric matrix)\n            angle_error = 0.5 * np.array([rot_error[2, 1], rot_error[0, 2], rot_error[1, 0]])\n\n            # Combined error\n            error = np.concatenate([pos_error, angle_error])\n\n            if np.linalg.norm(error) < tolerance:\n                break\n\n            # Calculate Jacobian\n            J = self.jacobian(current_joints)\n\n            # Update joint angles using pseudo-inverse of Jacobian\n            delta_theta = np.linalg.pinv(J) @ error * 0.1  # Step size factor\n            current_joints += delta_theta\n\n            # Apply joint limits (example limits)\n            joint_limits = np.array([[-np.pi, np.pi]] * self.num_joints)\n            current_joints = np.clip(current_joints, joint_limits[:, 0], joint_limits[:, 1])\n\n        return current_joints\n\n# Example usage for a 6-DOF manipulator\ndef example_manipulator():\n    # DH parameters for a 6-DOF manipulator [a, alpha, d, theta_offset]\n    dh_params = [\n        [0, -np.pi/2, 0.1, 0],      # Joint 1\n        [0.4, 0, 0, 0],             # Joint 2\n        [0, np.pi/2, 0.05, 0],      # Joint 3\n        [0, -np.pi/2, 0.4, 0],      # Joint 4\n        [0, np.pi/2, 0, 0],         # Joint 5\n        [0, 0, 0.1, 0]              # Joint 6\n    ]\n\n    manipulator = ManipulatorKinematics(dh_params)\n\n    # Example: Calculate forward kinematics\n    joint_angles = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]\n    pos, rot, transform = manipulator.forward_kinematics(joint_angles)\n    print(f"End-effector position: {pos}")\n    print(f"End-effector orientation: {rot}")\n\n    # Example: Calculate inverse kinematics\n    target_pose = np.array([0.3, 0.2, 0.5, 0.1, 0.1, 0.1])  # [x, y, z, rx, ry, rz]\n    solution = manipulator.inverse_kinematics(target_pose)\n    print(f"Inverse kinematics solution: {solution}")\n'})}),"\n",(0,a.jsx)(e.h3,{id:"grasp-planning-and-execution",children:"Grasp Planning and Execution"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom scipy.spatial.distance import cdist\nfrom scipy.optimize import minimize\nimport open3d as o3d\n\nclass GraspPlanner:\n    def __init__(self, gripper_width=0.08, finger_length=0.05):\n        self.gripper_width = gripper_width\n        self.finger_length = finger_length\n        self.min_grasp_quality = 0.3\n\n    def estimate_surface_normals(self, points):\n        """Estimate surface normals for point cloud"""\n        pcd = o3d.geometry.PointCloud()\n        pcd.points = o3d.utility.Vector3dVector(points)\n\n        # Estimate normals\n        pcd.estimate_normals(search_param=o3d.geometry.KDTreeSearchParamHybrid(\n            radius=0.1, max_nn=30))\n\n        return np.asarray(pcd.normals)\n\n    def find_grasp_candidates(self, object_points, normals=None):\n        """Find potential grasp points on object surface"""\n        if normals is None:\n            normals = self.estimate_surface_normals(object_points)\n\n        candidates = []\n\n        for i, (point, normal) in enumerate(zip(object_points, normals)):\n            # Skip points with invalid normals\n            if np.linalg.norm(normal) < 0.1:\n                continue\n\n            # Generate multiple grasp orientations around the normal\n            for angle in np.linspace(0, 2*np.pi, 8):\n                # Create rotation matrix for grasp orientation\n                grasp_orientation = self.align_with_normal(normal, angle)\n\n                # Calculate grasp quality\n                quality = self.evaluate_grasp_quality(point, grasp_orientation, object_points)\n\n                if quality > self.min_grasp_quality:\n                    candidate = {\n                        \'position\': point,\n                        \'orientation\': grasp_orientation,\n                        \'quality\': quality,\n                        \'normal\': normal\n                    }\n                    candidates.append(candidate)\n\n        return candidates\n\n    def align_with_normal(self, normal, angle):\n        """Align grasp orientation with surface normal"""\n        # Normalize the normal vector\n        normal = normal / np.linalg.norm(normal)\n\n        # Create a rotation matrix where z-axis aligns with normal\n        z_axis = normal\n        x_axis = np.array([1, 0, 0])\n\n        # If normal is parallel to x-axis, use different vector\n        if abs(np.dot(z_axis, x_axis)) > 0.99:\n            x_axis = np.array([0, 1, 0])\n\n        # Create orthogonal vectors\n        y_axis = np.cross(z_axis, x_axis)\n        y_axis = y_axis / np.linalg.norm(y_axis)\n        x_axis = np.cross(y_axis, z_axis)\n        x_axis = x_axis / np.linalg.norm(x_axis)\n\n        # Apply rotation around z-axis\n        cos_a, sin_a = np.cos(angle), np.sin(angle)\n        x_rot = cos_a * x_axis + sin_a * y_axis\n        y_rot = -sin_a * x_axis + cos_a * y_axis\n\n        return np.column_stack([x_rot, y_rot, z_axis])\n\n    def evaluate_grasp_quality(self, position, orientation, object_points):\n        """Evaluate the quality of a grasp pose"""\n        # Check if grasp region has sufficient contact points\n        grasp_region = self.get_grasp_region(position, orientation)\n\n        # Calculate distances from grasp center to object points\n        distances = cdist([position], object_points)[0]\n\n        # Count points within grasp region\n        in_region = distances < (self.gripper_width / 2)\n        contact_points = np.sum(in_region)\n\n        # Calculate grasp stability based on contact distribution\n        if contact_points < 3:\n            return 0.0\n\n        # Calculate grasp wrench space (simplified)\n        # A good grasp should have contacts on opposite sides\n        region_points = object_points[in_region]\n        if len(region_points) < 2:\n            return 0.0\n\n        # Calculate spread of contact points\n        centroid = np.mean(region_points, axis=0)\n        spread = np.std(region_points - centroid, axis=0)\n        spread_metric = np.mean(spread)\n\n        # Quality based on spread and number of contacts\n        quality = min(1.0, (contact_points * spread_metric) / 10.0)\n\n        return quality\n\n    def get_grasp_region(self, position, orientation):\n        """Define the region where a grasp would make contact"""\n        # Create a box representing the gripper jaw area\n        half_width = self.gripper_width / 2\n        half_length = self.finger_length / 2\n\n        # Define corners of the grasp region\n        corners = np.array([\n            [-half_width, -half_length, 0],\n            [half_width, -half_length, 0],\n            [half_width, half_length, 0],\n            [-half_width, half_length, 0]\n        ])\n\n        # Transform to world coordinates\n        transformed_corners = np.dot(corners, orientation.T) + position\n\n        return transformed_corners\n\n    def select_best_grasps(self, candidates, num_grasps=5):\n        """Select the best grasp candidates"""\n        if len(candidates) == 0:\n            return []\n\n        # Sort candidates by quality\n        sorted_candidates = sorted(candidates, key=lambda x: x[\'quality\'], reverse=True)\n\n        # Select top candidates\n        best_grasps = sorted_candidates[:num_grasps]\n\n        return best_grasps\n\nclass ManipulationController:\n    def __init__(self, kinematics_solver):\n        self.kinematics = kinematics_solver\n        self.grasp_planner = GraspPlanner()\n        self.approach_distance = 0.1  # 10cm approach distance\n\n    def plan_grasp_trajectory(self, grasp_pose, object_pose):\n        """Plan trajectory from approach to grasp position"""\n        # Calculate approach pose (above the grasp point)\n        approach_pose = grasp_pose.copy()\n        approach_pose[2] += self.approach_distance  # Move up by approach distance\n\n        # Plan path from current to approach\n        current_joints = self.get_current_joints()\n        approach_joints = self.kinematics.inverse_kinematics(approach_pose, current_joints)\n\n        # Plan path from approach to grasp\n        grasp_joints = self.kinematics.inverse_kinematics(grasp_pose, approach_joints)\n\n        # Plan path from grasp back to approach\n        retract_joints = approach_joints  # Same as approach for simplicity\n\n        return {\n            \'approach\': approach_joints,\n            \'grasp\': grasp_joints,\n            \'retract\': retract_joints\n        }\n\n    def execute_grasp(self, grasp_joints):\n        """Execute the grasp motion"""\n        # Move to approach position\n        self.move_to_joints(grasp_joints[\'approach\'])\n\n        # Move to grasp position\n        self.move_to_joints(grasp_joints[\'grasp\'])\n\n        # Close gripper\n        self.close_gripper()\n\n        # Move to retract position\n        self.move_to_joints(grasp_joints[\'retract\'])\n\n    def get_current_joints(self):\n        """Get current joint positions from robot"""\n        # This would interface with the actual robot\n        return np.zeros(self.kinematics.num_joints)\n\n    def move_to_joints(self, target_joints):\n        """Move robot to target joint positions"""\n        # This would send commands to the robot\n        print(f"Moving to joints: {target_joints}")\n\n    def close_gripper(self):\n        """Close the gripper"""\n        print("Closing gripper")\n\n# Example usage\ndef example_grasp_planning():\n    # Create a simple object point cloud (cube)\n    object_points = []\n    for x in np.linspace(-0.05, 0.05, 10):\n        for y in np.linspace(-0.05, 0.05, 10):\n            for z in [0.05]:  # Top surface of cube\n                object_points.append([x, y, z])\n\n    object_points = np.array(object_points)\n\n    # Plan grasps\n    planner = GraspPlanner()\n    candidates = planner.find_grasp_candidates(object_points)\n    best_grasps = planner.select_best_grasps(candidates, 3)\n\n    print(f"Found {len(candidates)} grasp candidates")\n    print(f"Selected {len(best_grasps)} best grasps")\n\n    for i, grasp in enumerate(best_grasps):\n        print(f"Grasp {i+1}: Quality={grasp[\'quality\']:.3f}, "\n              f"Position=({grasp[\'position\'][0]:.3f}, {grasp[\'position\'][1]:.3f}, {grasp[\'position\'][2]:.3f})")\n'})}),"\n",(0,a.jsx)(e.h3,{id:"vision-based-object-recognition-and-pose-estimation",children:"Vision-Based Object Recognition and Pose Estimation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import cv2\nimport numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\nclass ObjectPoseEstimator:\n    def __init__(self):\n        # Initialize SIFT detector for feature matching\n        self.detector = cv2.SIFT_create()\n        self.matcher = cv2.BFMatcher()\n\n        # Object models (in a real system, these would be loaded from files)\n        self.object_models = {}\n        self.camera_matrix = np.array([[525.0, 0.0, 319.5],\n                                      [0.0, 525.0, 239.5],\n                                      [0.0, 0.0, 1.0]])\n\n    def register_object_model(self, name, image, points_3d):\n        """Register a 3D object model with its 2D image features"""\n        # Detect features in the model image\n        kp, desc = self.detector.detectAndCompute(image, None)\n\n        self.object_models[name] = {\n            \'keypoints\': kp,\n            \'descriptors\': desc,\n            \'points_3d\': points_3d\n        }\n\n    def estimate_pose(self, image, object_name):\n        """Estimate 6D pose of known object in image"""\n        if object_name not in self.object_models:\n            return None, None\n\n        model = self.object_models[object_name]\n\n        # Detect features in current image\n        kp_scene, desc_scene = self.detector.detectAndCompute(image, None)\n\n        if desc_scene is None:\n            return None, None\n\n        # Match features between model and scene\n        matches = self.matcher.knnMatch(model[\'descriptors\'], desc_scene, k=2)\n\n        # Apply Lowe\'s ratio test\n        good_matches = []\n        for m, n in matches:\n            if m.distance < 0.75 * n.distance:\n                good_matches.append(m)\n\n        # Require minimum number of matches\n        if len(good_matches) < 10:\n            return None, None\n\n        # Extract matched points\n        src_pts = np.float32([model[\'keypoints\'][m.queryIdx].pt for m in good_matches]).reshape(-1, 1, 2)\n        dst_pts = np.float32([kp_scene[m.trainIdx].pt for m in good_matches]).reshape(-1, 1, 2)\n\n        # Get 3D points corresponding to matched 2D points\n        obj_pts = np.float32([model[\'points_3d\'][m.queryIdx] for m in good_matches]).reshape(-1, 1, 3)\n\n        # Solve Perspective-n-Point problem\n        success, rvec, tvec = cv2.solvePnP(obj_pts, dst_pts, self.camera_matrix, None)\n\n        if success:\n            # Convert rotation vector to matrix\n            rotation_matrix, _ = cv2.Rodrigues(rvec)\n\n            # Convert to position and Euler angles\n            position = tvec.flatten()\n            rotation = R.from_matrix(rotation_matrix).as_euler(\'xyz\')\n\n            return position, rotation\n        else:\n            return None, None\n\nclass ManipulationPipeline:\n    def __init__(self):\n        self.pose_estimator = ObjectPoseEstimator()\n        self.grasp_planner = GraspPlanner()\n        self.controller = None  # Will be set later\n\n    def register_object_models(self):\n        """Register known object models"""\n        # Example: Register a simple cube model\n        # In practice, this would load from files\n        cube_points = []\n        for x in [-0.05, 0.05]:\n            for y in [-0.05, 0.05]:\n                for z in [-0.05, 0.05]:\n                    cube_points.append([x, y, z])\n\n        cube_image = np.zeros((200, 200, 3), dtype=np.uint8)  # Dummy image\n        # Draw cube projection on image (simplified)\n        cv2.rectangle(cube_image, (50, 50), (150, 150), (255, 255, 255), 2)\n\n        self.pose_estimator.register_object_model(\'cube\', cube_image, np.array(cube_points))\n\n    def execute_pick_and_place(self, target_object, place_position):\n        """Execute pick and place operation"""\n        # Capture image\n        image = self.capture_image()  # This would interface with camera\n\n        # Estimate object pose\n        obj_pos, obj_rot = self.pose_estimator.estimate_pose(image, target_object)\n\n        if obj_pos is None:\n            print(f"Could not find {target_object}")\n            return False\n\n        print(f"Found {target_object} at position: {obj_pos}")\n\n        # Plan grasp on the object\n        # This is a simplified approach - in reality, you\'d use 3D point cloud\n        grasp_pose = obj_pos.copy()\n        grasp_pose[2] += 0.05  # Lift slightly above object center\n\n        # Plan and execute grasp\n        grasp_joints = self.controller.plan_grasp_trajectory(\n            np.concatenate([grasp_pose, obj_rot]),\n            np.concatenate([obj_pos, obj_rot])\n        )\n\n        self.controller.execute_grasp(grasp_joints)\n\n        # Move to place position\n        place_pose = np.concatenate([place_position, [0, 0, 0]])  # Zero rotation for placement\n        place_joints = self.controller.kinematics.inverse_kinematics(place_pose)\n\n        self.controller.move_to_joints(place_joints)\n\n        # Release object\n        self.open_gripper()\n\n        return True\n\n    def capture_image(self):\n        """Capture image from camera"""\n        # This would interface with actual camera\n        return np.zeros((480, 640, 3), dtype=np.uint8)\n\n    def open_gripper(self):\n        """Open the gripper"""\n        print("Opening gripper")\n'})}),"\n",(0,a.jsx)(e.h2,{id:"urdf-examples",children:"URDF Examples"}),"\n",(0,a.jsx)(e.h3,{id:"manipulator-robot-with-gripper",children:"Manipulator Robot with Gripper"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="manipulator_robot">\n  \x3c!-- Base Link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.2" length="0.1"/>\n      </geometry>\n      <material name="dark_gray">\n        <color rgba="0.3 0.3 0.3 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.2" length="0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="5.0"/>\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.05"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Shoulder Joint --\x3e\n  <joint name="shoulder_pan_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="shoulder_link"/>\n    <origin xyz="0 0 0.05" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-2.618" upper="2.618" effort="100" velocity="1.0"/>\n    <dynamics damping="1.0" friction="0.1"/>\n  </joint>\n\n  <link name="shoulder_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.08" length="0.1"/>\n      </geometry>\n      <material name="silver">\n        <color rgba="0.7 0.7 0.7 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.08" length="0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.005"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Upper Arm --\x3e\n  <joint name="shoulder_lift_joint" type="revolute">\n    <parent link="shoulder_link"/>\n    <child link="upper_arm_link"/>\n    <origin xyz="0 0 0.1" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="1.0"/>\n    <dynamics damping="1.0" friction="0.1"/>\n  </joint>\n\n  <link name="upper_arm_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.06" length="0.3"/>\n      </geometry>\n      <material name="steel">\n        <color rgba="0.5 0.5 0.5 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.06" length="0.3"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="3.0"/>\n      <inertia ixx="0.05" ixy="0.0" ixz="0.0" iyy="0.05" iyz="0.0" izz="0.002"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Elbow Joint --\x3e\n  <joint name="elbow_joint" type="revolute">\n    <parent link="upper_arm_link"/>\n    <child link="forearm_link"/>\n    <origin xyz="0 0 0.3" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-2.094" upper="2.094" effort="100" velocity="1.0"/>\n    <dynamics damping="1.0" friction="0.1"/>\n  </joint>\n\n  <link name="forearm_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.05" length="0.25"/>\n      </geometry>\n      <material name="steel">\n        <color rgba="0.5 0.5 0.5 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.05" length="0.25"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <inertia ixx="0.03" ixy="0.0" ixz="0.0" iyy="0.03" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Wrist Joints --\x3e\n  <joint name="wrist_1_joint" type="revolute">\n    <parent link="forearm_link"/>\n    <child link="wrist_1_link"/>\n    <origin xyz="0 0 0.25" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-2.618" upper="2.618" effort="50" velocity="1.5"/>\n    <dynamics damping="0.5" friction="0.05"/>\n  </joint>\n\n  <link name="wrist_1_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.04" length="0.08"/>\n      </geometry>\n      <material name="aluminum">\n        <color rgba="0.8 0.8 0.8 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.04" length="0.08"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.5"/>\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.0005"/>\n    </inertial>\n  </link>\n\n  <joint name="wrist_2_joint" type="revolute">\n    <parent link="wrist_1_link"/>\n    <child link="wrist_2_link"/>\n    <origin xyz="0 0 0.04" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-2.618" upper="2.618" effort="50" velocity="1.5"/>\n    <dynamics damping="0.5" friction="0.05"/>\n  </joint>\n\n  <link name="wrist_2_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.04" length="0.04"/>\n      </geometry>\n      <material name="aluminum">\n        <color rgba="0.8 0.8 0.8 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.04" length="0.04"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.3"/>\n      <inertia ixx="0.0005" ixy="0.0" ixz="0.0" iyy="0.0005" iyz="0.0" izz="0.0003"/>\n    </inertial>\n  </link>\n\n  \x3c!-- End Effector --\x3e\n  <joint name="wrist_3_joint" type="revolute">\n    <parent link="wrist_2_link"/>\n    <child link="ee_link"/>\n    <origin xyz="0 0 0.02" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="-2.618" upper="2.618" effort="30" velocity="2.0"/>\n    <dynamics damping="0.2" friction="0.02"/>\n  </joint>\n\n  <link name="ee_link">\n    <visual>\n      <geometry>\n        <box size="0.02 0.04 0.04"/>\n      </geometry>\n      <material name="red">\n        <color rgba="1.0 0.0 0.0 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.02 0.04 0.04"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.2"/>\n      <inertia ixx="0.0002" ixy="0.0" ixz="0.0" iyy="0.0003" iyz="0.0" izz="0.0003"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Parallel Jaw Gripper --\x3e\n  <joint name="gripper_joint" type="prismatic">\n    <parent link="ee_link"/>\n    <child link="gripper_body"/>\n    <origin xyz="0.01 0 0" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="0.0" upper="0.08" effort="20" velocity="0.5"/>\n    <dynamics damping="2.0"/>\n  </joint>\n\n  <link name="gripper_body">\n    <visual>\n      <geometry>\n        <box size="0.08 0.02 0.02"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0.1 0.1 0.1 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.08 0.02 0.02"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.1"/>\n      <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.00005" iyz="0.0" izz="0.00005"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Left Finger --\x3e\n  <joint name="left_finger_joint" type="prismatic">\n    <parent link="gripper_body"/>\n    <child link="left_finger"/>\n    <origin xyz="0.04 0 0" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="0.0" upper="0.03" effort="10" velocity="0.2"/>\n    <mimic joint="gripper_joint" multiplier="0.5" offset="0"/>\n  </joint>\n\n  <link name="left_finger">\n    <visual>\n      <geometry>\n        <box size="0.01 0.06 0.02"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0.0 0.0 1.0 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.01 0.06 0.02"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.05"/>\n      <inertia ixx="0.00005" ixy="0.0" ixz="0.0" iyy="0.00001" iyz="0.0" izz="0.00005"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Right Finger --\x3e\n  <joint name="right_finger_joint" type="prismatic">\n    <parent link="gripper_body"/>\n    <child link="right_finger"/>\n    <origin xyz="0.04 0 0" rpy="0 0 0"/>\n    <axis xyz="0 -1 0"/>\n    <limit lower="0.0" upper="0.03" effort="10" velocity="0.2"/>\n    <mimic joint="gripper_joint" multiplier="0.5" offset="0"/>\n  </joint>\n\n  <link name="right_finger">\n    <visual>\n      <geometry>\n        <box size="0.01 0.06 0.02"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0.0 0.0 1.0 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.01 0.06 0.02"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.05"/>\n      <inertia ixx="0.00005" ixy="0.0" ixz="0.0" iyy="0.00001" iyz="0.0" izz="0.00005"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Camera for vision --\x3e\n  <joint name="camera_joint" type="fixed">\n    <parent link="ee_link"/>\n    <child link="camera_link"/>\n    <origin xyz="0.05 0 0" rpy="0 0 0"/>\n  </joint>\n\n  <link name="camera_link">\n    <visual>\n      <geometry>\n        <box size="0.02 0.02 0.01"/>\n      </geometry>\n    </visual>\n  </link>\n\n  \x3c!-- Gazebo plugins --\x3e\n  <gazebo reference="base_link">\n    <material>Gazebo/Gray</material>\n  </gazebo>\n\n  <gazebo reference="camera_link">\n    <sensor name="camera" type="camera">\n      <always_on>true</always_on>\n      <update_rate>30</update_rate>\n      <camera>\n        <horizontal_fov>1.047</horizontal_fov>\n        <image>\n          <width>640</width>\n          <height>480</height>\n        </image>\n        <clip>\n          <near>0.1</near>\n          <far>10</far>\n        </clip>\n      </camera>\n      <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n        <frame_name>camera_link</frame_name>\n        <topic_name>camera/image_raw</topic_name>\n      </plugin>\n    </sensor>\n  </gazebo>\n\n  \x3c!-- Position controllers for joints --\x3e\n  <gazebo>\n    <plugin name="joint_state_publisher" filename="libgazebo_ros_joint_state_publisher.so">\n      <joint_name>shoulder_pan_joint, shoulder_lift_joint, elbow_joint, wrist_1_joint, wrist_2_joint, wrist_3_joint, gripper_joint</joint_name>\n    </plugin>\n  </gazebo>\n\n  \x3c!-- Joint position controllers --\x3e\n  <gazebo>\n    <plugin name="ros_control" filename="libgazebo_ros_control.so">\n      <robotNamespace>/manipulator</robotNamespace>\n    </plugin>\n  </gazebo>\n\n  \x3c!-- Transmission for ROS Control --\x3e\n  <transmission name="shoulder_pan_trans">\n    <type>transmission_interface/SimpleTransmission</type>\n    <joint name="shoulder_pan_joint">\n      <hardwareInterface>position_controllers/JointPositionInterface</hardwareInterface>\n    </joint>\n    <actuator name="shoulder_pan_motor">\n      <mechanicalReduction>1</mechanicalReduction>\n    </actuator>\n  </transmission>\n\n  <transmission name="shoulder_lift_trans">\n    <type>transmission_interface/SimpleTransmission</type>\n    <joint name="shoulder_lift_joint">\n      <hardwareInterface>position_controllers/JointPositionInterface</hardwareInterface>\n    </joint>\n    <actuator name="shoulder_lift_motor">\n      <mechanicalReduction>1</mechanicalReduction>\n    </actuator>\n  </transmission>\n\n  <transmission name="elbow_trans">\n    <type>transmission_interface/SimpleTransmission</type>\n    <joint name="elbow_joint">\n      <hardwareInterface>position_controllers/JointPositionInterface</hardwareInterface>\n    </joint>\n    <actuator name="elbow_motor">\n      <mechanicalReduction>1</mechanicalReduction>\n    </actuator>\n  </transmission>\n\n  <transmission name="wrist_1_trans">\n    <type>transmission_interface/SimpleTransmission</type>\n    <joint name="wrist_1_joint">\n      <hardwareInterface>position_controllers/JointPositionInterface</hardwareInterface>\n    </joint>\n    <actuator name="wrist_1_motor">\n      <mechanicalReduction>1</mechanicalReduction>\n    </actuator>\n  </transmission>\n\n  <transmission name="wrist_2_trans">\n    <type>transmission_interface/SimpleTransmission</type>\n    <joint name="wrist_2_joint">\n      <hardwareInterface>position_controllers/JointPositionInterface</hardwareInterface>\n    </joint>\n    <actuator name="wrist_2_motor">\n      <mechanicalReduction>1</mechanicalReduction>\n    </actuator>\n  </transmission>\n\n  <transmission name="wrist_3_trans">\n    <type>transmission_interface/SimpleTransmission</type>\n    <joint name="wrist_3_joint">\n      <hardwareInterface>position_controllers/JointPositionInterface</hardwareInterface>\n    </joint>\n    <actuator name="wrist_3_motor">\n      <mechanicalReduction>1</mechanicalReduction>\n    </actuator>\n  </transmission>\n\n  <transmission name="gripper_trans">\n    <type>transmission_interface/SimpleTransmission</type>\n    <joint name="gripper_joint">\n      <hardwareInterface>position_controllers/JointPositionInterface</hardwareInterface>\n    </joint>\n    <actuator name="gripper_motor">\n      <mechanicalReduction>1</mechanicalReduction>\n    </actuator>\n  </transmission>\n</robot>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"manipulation-pipeline-diagram",children:"Manipulation Pipeline Diagram"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-mermaid",children:"graph TD\n    A[Object Detection] --\x3e B[Pose Estimation]\n    B --\x3e C[Grasp Planning]\n    C --\x3e D[Trajectory Planning]\n    D --\x3e E[Inverse Kinematics]\n    E --\x3e F[Control Execution]\n    F --\x3e G[Grasp Execution]\n    G --\x3e H[Object Transport]\n    H --\x3e I[Placement]\n    I --\x3e J[Release]\n    J --\x3e K[Retraction]\n\n    style A fill:#ff9999\n    style C fill:#99ff99\n    style F fill:#99ccff\n"})}),"\n",(0,a.jsx)(e.h2,{id:"manipulation-strategies-comparison",children:"Manipulation Strategies Comparison"}),"\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"Strategy"}),(0,a.jsx)(e.th,{children:"Advantages"}),(0,a.jsx)(e.th,{children:"Disadvantages"}),(0,a.jsx)(e.th,{children:"Best For"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"Top Grasp"}),(0,a.jsx)(e.td,{children:"Stable, reliable"}),(0,a.jsx)(e.td,{children:"Limited to top surfaces"}),(0,a.jsx)(e.td,{children:"Cuboidal objects"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"Side Grasp"}),(0,a.jsx)(e.td,{children:"Access to sides"}),(0,a.jsx)(e.td,{children:"Less stable"}),(0,a.jsx)(e.td,{children:"Cylindrical objects"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"Pinch Grasp"}),(0,a.jsx)(e.td,{children:"Precise, delicate"}),(0,a.jsx)(e.td,{children:"Lower payload"}),(0,a.jsx)(e.td,{children:"Small objects"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"Wrap Grasp"}),(0,a.jsx)(e.td,{children:"High payload"}),(0,a.jsx)(e.td,{children:"Complex planning"}),(0,a.jsx)(e.td,{children:"Irregular shapes"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"Suction"}),(0,a.jsx)(e.td,{children:"No physical contact"}),(0,a.jsx)(e.td,{children:"Only works on smooth surfaces"}),(0,a.jsx)(e.td,{children:"Flat objects"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"Clamp"}),(0,a.jsx)(e.td,{children:"High force"}),(0,a.jsx)(e.td,{children:"Requires specific geometry"}),(0,a.jsx)(e.td,{children:"Rod-like objects"})]})]})]}),"\n",(0,a.jsx)(e.h2,{id:"key-terms",children:"Key Terms"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"DH Parameters"}),": Denavit-Hartenberg parameters for kinematic modeling"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Jacobian"}),": Matrix relating joint velocities to end-effector velocities"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Grasp Stability"}),": Measure of how securely an object is held"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Wrench Space"}),": Set of forces and torques a grasp can resist"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Anti-Podal Grasp"}),": Grasp where contact forces oppose each other"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Friction Cone"}),": Range of directions for which friction prevents slip"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Manipulability"}),": Measure of how well a manipulator can move in different directions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Workspace"}),": Reachable space of the manipulator's end-effector"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"learning-checkpoints",children:"Learning Checkpoints"}),"\n",(0,a.jsx)(e.h3,{id:"quiz-questions",children:"Quiz Questions"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"What are the main differences between forward and inverse kinematics?"}),"\n",(0,a.jsx)(e.li,{children:"Explain the concept of a friction cone in grasp analysis."}),"\n",(0,a.jsx)(e.li,{children:"What factors determine the quality of a robotic grasp?"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"practical-exercise",children:"Practical Exercise"}),"\n",(0,a.jsx)(e.p,{children:"Implement a simple inverse kinematics solver for a 3-DOF planar manipulator and visualize the workspace."}),"\n",(0,a.jsx)(e.h2,{id:"hands-on-exercise",children:"Hands-On Exercise"}),"\n",(0,a.jsx)(e.p,{children:"Create a complete manipulation pipeline that integrates vision-based object detection, grasp planning, and trajectory execution using your robot model."}),"\n",(0,a.jsx)(e.h2,{id:"personalization",children:"Personalization"}),"\n",(0,a.jsxs)("div",{className:"personalization-options",children:[(0,a.jsx)("h3",{children:"Adjust Learning Path:"}),(0,a.jsx)("button",{onClick:()=>setDifficulty("beginner"),children:"Beginner"}),(0,a.jsx)("button",{onClick:()=>setDifficulty("intermediate"),children:"Intermediate"}),(0,a.jsx)("button",{onClick:()=>setDifficulty("advanced"),children:"Advanced"})]}),"\n",(0,a.jsx)(e.h2,{id:"translation",children:"Translation"}),"\n",(0,a.jsx)("div",{className:"translation-controls",children:(0,a.jsx)("button",{onClick:()=>translateToUrdu(),children:"\u0627\u0631\u062f\u0648 \u0645\u06cc\u06ba \u062a\u0631\u062c\u0645\u06c1 \u06a9\u0631\u06cc\u06ba"})})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(p,{...n})}):p(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>s});var t=i(6540);const a={},r=t.createContext(a);function o(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),t.createElement(r.Provider,{value:e},n.children)}}}]);